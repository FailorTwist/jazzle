Scope { parent, type, refs, defs, scopeID, scs, diStart, allowedActions, flags, hasTZCheckpoint }

ConcreteScope < Scope { liquidDefs, synthNamesUntilNow, special::{ _this } }

FunScope < ConcreteScope { argList, argMap, argRefs, prologue, scopeName, firstNonSimple, firstDup, firstEvalOrArguments, inBody, special::{ _scall, _this, _arguments } }

ClassScope < Scope { scopeName }

CatchScope { argList, argMap, argRefs, argsIsSimple, argsIsSignificant, inBody }

Decl { ref, liquid, name, hasTZCheck, liquid, reached, site, idx }

Ref { i, lors, scope, d, targetDecl, isResolved, parentDecl }

Liquid < Decl { category<:string:>, crsMap }

GlobalScope { scriptScope }

ModuleScope { inNames, outNames }

Scope::`{
  isAnyFn, isCatch, isScript, isModule, isClass isGen, isAsync, isAccessor, isGetter, isSetter, isObjMem, isArrow, isClassMem, isCtor, isBlock, isExpr, isDecl, isStaticMem, isBare, isSoft, /* i.e, not an fn*/ isConcrete, isConditional
  insideIf, insideLoop, insideStrict, insideUniqueArgs, insideFnArgs, insideForInit,
  canContinue, canReturn, canBreak, canDeclareLetOrClass, canDeclareFunc, canYield, canAwait, canCallSuper, canMemSuper,
  hasNewTarget,
  enterForInit/exitForInit, enterStrict/exitStrict,
  yieldIsKW, awaitIsKW,
  spawnCatch, spawnBare, spawnFn, spawnParen, spawnCls,
  useLiquid
  declare, reference,
  hasSignificantNames
  finish
  handOverRefs
  tzOn
  hasTZFor(decl)
}

ConcreteScope {
  findSynth /* find a name in the _emit-names_, i.e, emulate a name resolution that is going to happen in the emitted code; used to find and eliminate name collisions */, bootSynth, startupSynth, endSynth, synthDecl, synthLiquid
  findLiquid, createLiquid
  gocThis
}

FuncScope {
  canDup
  setName
  makeArgsUnique
  exitUniqueArgs
  gocArguments
  verifyForStrictness
  gocSupCall/gocSupMem
}

ClassScope {
  setName
  hasHeritage
  gocSupCall/gocSupMem
}

Decl {
  isVar, isLet, isConst, isLlinosa, isCls, isCatchArg, isFn, isFnArg, isClsName, isFnName
  tzOn, isSpecial, isSynglo /* synthesized global */
}

Ref {
  absorb
  resolveTo
}

ScopeTypes { GLOBAL, MODULE, SCRIPT, DECL, CLS, FN, CLSMEM, SETTER, GETTER, STATICMEM, CTOR, OBJMEM, OBJ, ARROW, BLOCK, CATCH, ASYNC, BARE, METH, EXPR, GEN, PAREN }

ScopeFlags { LOOP, UNIQUE, STRICT, ARGS, IF, COND, FOR_INIT, WITH_SUPCALL, YIELD_KW, AWAIT_KW }

ScopeActions { THROW, AWAIT, BREAK, RETURN, YIELD, CONTINUE, CALL_SUPER, MEM_SUPER }

DeclTypes { CLS, FN, CONST, VAR, CATCHARG, SPECIAL, LET, ARGUMENTS, FNARG, FNNAME, CLSNAME, GLOBAL, CONTEXTUAL }

`makeArgsUnique() {
  :@assert !`inBody, 'must be in args'
  !`canDup() && return
  `verifyArgsForUniqueness()
  `flags |= ScopeFlags::UNIQUE
}

`exitUnique() { 
  :@assert !`inBody, 'must be in args'
  :@assert `insideUniqueArgs(), 'must be in unique args'
  `flags &= ScopeFlags::UNIQUE
}

`synthGlobals
