this.regParen =
function() {
  var c0 = this.c;
  var s = this.src;
  var l = s.length;

  if (c0+1 >= l)
    return this.regErr_EOFParen();

  if (s.charCodeAt(c0+1) === CH_QUESTION)
    return this.regPeekOrGroup();

  var loc0 = this.loc();
  this.setsimpoff(c0+1);

  var elem = this.regPattern();
  if (this.regErr)
    return null;

  this.regIsQuantifiable = true;
  var unfinished = this.expectChar(CH_RPAREN);
  var n = {
    type: '#Regex.Paren',
    capturing: true,
    start: c0,
    end: this.c,
    pattern: elem,
    loc: { start: loc0, end: this.loc() }
  };

  if (unfinished)
    return this.regErr_unfinishedParen(n);

  return n;
};

this.regPeekOrGroup =
function() {
  var c0 = this.c, s = this.src, l = s.length;
  switch (this.scat(c0+2)) {
  case CH_EQUALITY_SIGN:
    return this.regPeek(true);
  case CH_EXCLAMATION:
    return this.regPeek(false);
  case CH_COLON:
    return this.regGroup();
  default:
    return this.regErr_invalidCharAfterQuestionParen(); // (?
  }
};

this.regPeek =
function(notInverse) {
  var c0 = this.c, loc0 = this.loc(), n = null, unfinished = false, elem = null;
  this.setsimpoff(c0+3);
  elem = this.regPattern();
  unfinished = this.expectChar(CH_RPAREN);
  n = {
    type: '#Regex.Peek',
    inverse: !notInverse,
    start: c0,
    pattern: elem,
    end: this.c,
    loc: { start: loc0, end: this.loc() }
  };

  return unfinished ? this.regErr_unfinishedParen(n) : n;
};
